# flashing_light_avr

Simple **flashing LED** project using an **AVR microcontroller**, written in **C** with **Atmel Studio** and simulated in **Proteus**.

This was created as an introductory embedded systems exercise to practice:

- Configuring AVR I/O pins as outputs  
- Implementing software (and/or timer-based) delays  
- Verifying behavior in simulation before deploying to real hardware  

> ℹ️ Update the exact microcontroller model and pin mapping below to match your setup (e.g. `ATmega16`, `ATmega32`, etc.).

---

## Features

- Toggles one or more LEDs at a fixed rate  
- Uses an AVR GPIO pin as digital output  
- Clear separation between **firmware** and **simulation**  
- Easy to extend to:
  - Multiple LEDs / patterns
  - Timer/interrupt-based blinking
  - Button-controlled blinking modes

---

## Tech Stack

- **Microcontroller:** AVR (e.g. ATmega series)  
- **Language:** C  
- **IDE / Toolchain:** Atmel Studio  
- **Simulation:** Proteus  

---

## Repository Structure

```text
flashing_light_avr/
├─ firmware/
│  ├─ flashing_light.c          # Main C source file (blinking logic)
│  ├─ flashing_light_avr.cproj  # Atmel Studio C project file
│  └─ flashing_light_avr.atsln  # Atmel Studio solution file
├─ simulation/
│  └─ p1.pdsprj                 # Proteus simulation project (MCU + LED circuit)
├─ .gitignore
└─ README.md
```

Build artifacts (e.g. `Debug/`, `Release/`, `.obj`, `.hex` etc.) are intentionally not committed to keep the repository clean.

---

## How It Works

At a high level, the firmware in `flashing_light.c`:

1. **Configures LED pin(s) as outputs** by setting the appropriate bits in the AVR data direction register (e.g. `DDRx`).  
2. Enters an **infinite loop**:
   - Sets the output pin high (LED ON)  
   - Waits for a delay  
   - Sets the output pin low (LED OFF)  
   - Waits for a delay  
3. Repeats forever, creating a visible flashing effect.

In **Proteus**, a simple circuit connects:

- The AVR microcontroller (loaded with the compiled HEX file)
- LED + current-limiting resistor on the configured output pin

---

## Getting Started

### Requirements

- **Atmel Studio** (for building/editing the firmware)  
- **Proteus** (for simulation)  
- Optional:  
  - AVR development board (e.g. ATmegaXX board)  
  - AVR programmer (USBasp, AVRISP, etc.)  
  - Breadboard, LED, resistors

---

### 1. Build the Firmware (Atmel Studio)

1. Open `firmware/flashing_light_avr.atsln` in **Atmel Studio**.  
2. Check the **Device / MCU** in project properties (e.g. `ATmega16`).  
3. Build the project:  
   - `Build → Build Solution`  
4. Note the generated HEX file path (usually under `Debug/` or `Release/`).

---

### 2. Run the Simulation (Proteus)

1. Open `simulation/p1.pdsprj` in **Proteus**.  
2. Double-click the microcontroller in the schematic and **load the HEX file** generated by Atmel Studio.  
3. Click **Run** in Proteus.  
4. You should see the LED(s) blinking according to the configured delay.

---

### 3. (Optional) Flash to Real Hardware

1. Connect your AVR board and programmer.  
2. Use `avrdude` or the Atmel Studio programmer to flash the HEX file.  
3. Wire an LED (with resistor) to the configured output pin and ground.  
4. Power the board — the LED should flash with the same pattern as in the simulation.

---

## Educational Objectives

This project is useful to demonstrate:

- Basic **embedded C** for AVR  
- Direct manipulation of **GPIO registers**  
- The concept of **busy-wait delays** vs **timer-based** delays  
- Using **simulation tools** (Proteus) to debug embedded systems

---

## Ideas for Extensions

- Replace software delay with **hardware timers + interrupts**  
- Add **multiple LEDs** with different blinking frequencies  
- Implement **PWM dimming** for brightness control  
- Add a **button** to cycle through multiple blink modes  

---

## Author

**Saber Sojudi**  
Project from my Bachelor’s studies in Computer Engineering, demonstrating basic AVR embedded programming and simulation.
